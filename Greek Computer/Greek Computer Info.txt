The Task: My Wife got me this Grecian Computer (https://www.amazon.com/True-Genius-Grecian-Computer/dp/B08469GT8K) for Valentine's Day. It is a series of wooden circles that have numbers on them. There are five circles that get progressively smaller as you move up the puzzle. The goal of the puzzle is to arrange the circles so that each of the twelve columns of numbers all add up to forty-two. I fiddled with this for a couple days after my wife got it for me, and I surmised that to solve it manually it would make sense to arrange it so that the six columns where the outer most series of numbers all added up to 42, then there would more than likely be a solution where you rotate the top 4 rings, and that solves for the other 6 columns (this description makes more sense if you look at the Amazon page).  Like I said, I messed with it for a few hours before I realized I was just solving it through trial and error. Therefore, I decided that I should just write a python script to try every combination and return the combination that solves the puzzle.

Background Information: this puzzle is modeled after the Antikythera Mechanism that was discovered off the Greek island of the same name in 1903. It was described as the world’s first analogue computer.

Timeline: 2 hours

First Thoughts:  My initial thinking is to assign each of the four rings of numbers as arrays, and then run through four loops evaluating each position of the other four rings, evaluate the total of each column and then return the sequence of numbers that results in twelve columns of forty-two. I figured I would use for loops, and I would use the increment variable in the for loop to cycle the distinct positions of the different rings. I would reduce the increment value using a modulo function so that the array value being assigned never goes above 11.

Lessons Learned:

Test often: I spun my puzzle so I could read all the values on the bottom most ring, and assigned those values to 4 different arrays and then wrote the first for loop for changing the second ring from the bottom, I tested here and found that the values on the outermost ring were changing appropriately, and then figured I had the solution cracked and then wrote the for loops for the other 3 rings, then I wrote the evaluation mechanism and then ran my code.  The first pass wasn't pretty, the initial code had more testing features so I could troubleshoot, and it would return how many 12s it found instead of just returning that it found 12 42s in X combination, the problem was that it said it found 36 42's, and the in the combination only four of the combinations added up to 42.  So, I clearly had a problem with the program’s logic.

The logic problem:  This was a tabulation problem,  I had the for loop that determines if a column adds up to 42 inside the while loop that builds the array to be evaluated, so it was evaluating the first number 12 times, the second number 11 times, the third number 10 times, and so on.  Once that was fixed, I ran the solution, it returned that it had found a solution with 6 42s, and at least the arrays indicated that there were 6 42s in the resulting spins. So, I also had a methodology problem.

The methodology problem:  When I first established my arrays, I made sure to establish them inside of the first for loop, I was thinking. hat I should reset the puzzle to its initial setup before each iteration due to how for loops cycles through the iterations. What I neglected to think about was that each for loop would need to reset its initial position to the end of the previous loop. In retrospect after I thought it through it was obvious. However, after I added variables to the end of each iteration cycle, it returned the same answer, which led me to the final problem.

Variables are weird:  This is broad, and just that I am not the most experienced coder, but my initial statements looked like this "Ring22 = Ring2" at the end of the previous loop, then "Ring2 = Ring22" at the start of the next one. I did not realize at the time that I was just establishing what amounts to an alias for Ring2 named Ring22, so that second statement was just saying "Ring2 = Ring2". To create a new array variable, I would have to add a [ : ] to the end so that each variable was unique, and they would stop overwriting each other.
